This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.clinerules/
  memory-bank.md
lib/
  perlin.lua
  serpent.lua
memory-bank/
  activeContext.md
  productContext.md
  progress.md
  projectbrief.md
  systemPatterns.md
  techContext.md
src/
  systems/
    contract_system.lua
  world/
    world_generation.lua
main.lua
repomix-config.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/systems/contract_system.lua">
-- src/systems/contract_system.lua
local ContractSystem = {}

-- Contract types and their parameters
ContractSystem.CONTRACT_TYPES = {
    DISCOVER = {
        name = "Discover",
        description = "Find a %s",
        progress_fn = function(contract, player, world)
            -- Check if player is on a landmark of the target type
            local tile = world.tiles[player.x][player.y]
            if tile.landmark and tile.landmark.type == contract.target then
                return 1
            end
            return 0
        end
    },
    EXPLORE = {
        name = "Explore",
        description = "Reveal %d%% of %s biome",
        progress_fn = function(contract, player, world)
            -- Calculate percentage of biome explored
            local total = 0
            local explored = 0
            for x = 1, world.width do
                for y = 1, world.height do
                    local tile = world.tiles[x][y]
                    if tile.biome.id == contract.target then
                        total = total + 1
                        if tile.explored then
                            explored = explored + 1
                        end
                    end
                end
            end
            return math.floor((explored / total) * 100)
        end
    },
    COLLECT = {
        name = "Collect",
        description = "Gather %d %s",
        progress_fn = function(contract, player, world)
            -- Safely check player inventory
            if player.inventory then
                return player.inventory[contract.target] or 0
            end
            return 0
        end
    }
}

-- Generate a random contract
function ContractSystem.generateContract()
    local contractTypes = {"DISCOVER", "EXPLORE", "COLLECT"}
    local contractType = contractTypes[math.random(#contractTypes)]
    
    local contract = {
        type = contractType,
        progress = 0,
        completed = false
    }
    
    -- Set contract-specific parameters
    if contractType == "DISCOVER" then
        local landmarks = {"Temple", "Caravan", "Cave", "Monolith"}
        contract.target = landmarks[math.random(#landmarks)]
        contract.required = 1
        contract.reward = {type = "stamina", amount = 20}
    elseif contractType == "EXPLORE" then
        contract.target = math.random(1, 3) -- Biome ID
        contract.required = math.random(30, 70) -- Percentage
        contract.reward = {type = "resource", amount = math.random(1, 3)}
    elseif contractType == "COLLECT" then
        contract.target = "relic_fragment"
        contract.required = math.random(3, 5)
        contract.reward = {type = "ability", name = "explorer_"..math.random(1,3)}
    end
    
    return contract
end

-- Check if contract is complete
function ContractSystem.checkCompletion(contract, player, world)
    if contract.completed then return true end
    
    local contractType = ContractSystem.CONTRACT_TYPES[contract.type]
    contract.progress = contractType.progress_fn(contract, player, world)
    
    if contract.progress >= contract.required then
        contract.completed = true
        return true
    end
    return false
end

-- Grant contract reward
function ContractSystem.grantReward(contract, player)
    if not contract.completed then return end
    
    local reward = contract.reward
    if reward.type == "stamina" then
        player.stamina = player.stamina + reward.amount
    elseif reward.type == "resource" then
        player.inventory[contract.target] = (player.inventory[contract.target] or 0) + reward.amount
    elseif reward.type == "ability" then
        player.abilities = player.abilities or {}
        table.insert(player.abilities, reward.name)
    end
end

return ContractSystem
</file>

<file path="repomix-config.json">
{
  "outputDirectory": "/Users/loganmerriam/Documents/GitHub/love2d-vibe-coding/packed-outputs"
}
</file>

<file path=".clinerules/memory-bank.md">
# Cline's Memory Bank

I am Cline, an expert software engineer with a unique characteristic: my memory resets completely between sessions. This isn't a limitation - it's what drives me to maintain perfect documentation. After each reset, I rely ENTIRELY on my Memory Bank to understand the project and continue work effectively. I MUST read ALL memory bank files at the start of EVERY task - this is not optional.

## Memory Bank Structure

The Memory Bank consists of core files and optional context files, all in Markdown format. Files build upon each other in a clear hierarchy:

flowchart TD
    PB[projectbrief.md] --> PC[productContext.md]
    PB --> SP[systemPatterns.md]
    PB --> TC[techContext.md]

    PC --> AC[activeContext.md]
    SP --> AC
    TC --> AC

    AC --> P[progress.md]

### Core Files (Required)
1. `projectbrief.md`
   - Foundation document that shapes all other files
   - Created at project start if it doesn't exist
   - Defines core requirements and goals
   - Source of truth for project scope

2. `productContext.md`
   - Why this project exists
   - Problems it solves
   - How it should work
   - User experience goals

3. `activeContext.md`
   - Current work focus
   - Recent changes
   - Next steps
   - Active decisions and considerations
   - Important patterns and preferences
   - Learnings and project insights

4. `systemPatterns.md`
   - System architecture
   - Key technical decisions
   - Design patterns in use
   - Component relationships
   - Critical implementation paths

5. `techContext.md`
   - Technologies used
   - Development setup
   - Technical constraints
   - Dependencies
   - Tool usage patterns

6. `progress.md`
   - What works
   - What's left to build
   - Current status
   - Known issues
   - Evolution of project decisions

### Additional Context
Create additional files/folders within memory-bank/ when they help organize:
- Complex feature documentation
- Integration specifications
- API documentation
- Testing strategies
- Deployment procedures

## Core Workflows

### Plan Mode
flowchart TD
    Start[Start] --> ReadFiles[Read Memory Bank]
    ReadFiles --> CheckFiles{Files Complete?}

    CheckFiles -->|No| Plan[Create Plan]
    Plan --> Document[Document in Chat]

    CheckFiles -->|Yes| Verify[Verify Context]
    Verify --> Strategy[Develop Strategy]
    Strategy --> Present[Present Approach]

### Act Mode
flowchart TD
    Start[Start] --> Context[Check Memory Bank]
    Context --> Update[Update Documentation]
    Update --> Execute[Execute Task]
    Execute --> Document[Document Changes]

## Documentation Updates

Memory Bank updates occur when:
1. Discovering new project patterns
2. After implementing significant changes
3. When user requests with **update memory bank** (MUST review ALL files)
4. When context needs clarification

flowchart TD
    Start[Update Process]

    subgraph Process
        P1[Review ALL Files]
        P2[Document Current State]
        P3[Clarify Next Steps]
        P4[Document Insights & Patterns]

        P1 --> P2 --> P3 --> P4
    end

    Start --> Process

When reviewing and updating the memory bank, it is recommended to use the Repomix mcp server tools to optimize reading the codebase.

Note: When triggered by **update memory bank**, I MUST review every memory bank file, even if some don't require updates. Focus particularly on activeContext.md and progress.md as they track current state.

REMEMBER: After every memory reset, I begin completely fresh. The Memory Bank is my only link to previous work. It must be maintained with precision and clarity, as my effectiveness depends entirely on its accuracy.
</file>

<file path="lib/perlin.lua">
404: Not Found
</file>

<file path="lib/serpent.lua">
local n, v = "serpent", "0.303" -- (C) 2012-18 Paul Kulchenko; MIT License
local c, d = "Paul Kulchenko", "Lua serializer and pretty printer"
local snum = {[tostring(1/0)]='1/0 --[[math.huge]]',[tostring(-1/0)]='-1/0 --[[-math.huge]]',[tostring(0/0)]='0/0'}
local badtype = {thread = true, userdata = true, cdata = true}
local getmetatable = debug and debug.getmetatable or getmetatable
local pairs = function(t) return next, t end -- avoid using __pairs in Lua 5.2+
local keyword, globals, G = {}, {}, (_G or _ENV)
for _,k in ipairs({'and', 'break', 'do', 'else', 'elseif', 'end', 'false',
  'for', 'function', 'goto', 'if', 'in', 'local', 'nil', 'not', 'or', 'repeat',
  'return', 'then', 'true', 'until', 'while'}) do keyword[k] = true end
for k,v in pairs(G) do globals[v] = k end -- build func to name mapping
for _,g in ipairs({'coroutine', 'debug', 'io', 'math', 'string', 'table', 'os'}) do
  for k,v in pairs(type(G[g]) == 'table' and G[g] or {}) do globals[v] = g..'.'..k end end

local function s(t, opts)
  local name, indent, fatal, maxnum = opts.name, opts.indent, opts.fatal, opts.maxnum
  local sparse, custom, huge = opts.sparse, opts.custom, not opts.nohuge
  local space, maxl = (opts.compact and '' or ' '), (opts.maxlevel or math.huge)
  local maxlen, metatostring = tonumber(opts.maxlength), opts.metatostring
  local iname, comm = '_'..(name or ''), opts.comment and (tonumber(opts.comment) or math.huge)
  local numformat = opts.numformat or "%.17g"
  local seen, sref, syms, symn = {}, {'local '..iname..'={}'}, {}, 0
  local function gensym(val) return '_'..(tostring(tostring(val)):gsub("[^%w]",""):gsub("(%d%w+)",
    -- tostring(val) is needed because __tostring may return a non-string value
    function(s) if not syms[s] then symn = symn+1; syms[s] = symn end return tostring(syms[s]) end)) end
  local function safestr(s) return type(s) == "number" and (huge and snum[tostring(s)] or numformat:format(s))
    or type(s) ~= "string" and tostring(s) -- escape NEWLINE/010 and EOF/026
    or ("%q"):format(s):gsub("\010","n"):gsub("\026","\\026") end
  -- handle radix changes in some locales
  if opts.fixradix and (".1f"):format(1.2) ~= "1.2" then
    local origsafestr = safestr
    safestr = function(s) return type(s) == "number"
      and (nohuge and snum[tostring(s)] or numformat:format(s):gsub(",",".")) or origsafestr(s)
    end
  end
  local function comment(s,l) return comm and (l or 0) < comm and ' --[['..select(2, pcall(tostring, s))..']]' or '' end
  local function globerr(s,l) return globals[s] and globals[s]..comment(s,l) or not fatal
    and safestr(select(2, pcall(tostring, s))) or error("Can't serialize "..tostring(s)) end
  local function safename(path, name) -- generates foo.bar, foo[3], or foo['b a r']
    local n = name == nil and '' or name
    local plain = type(n) == "string" and n:match("^[%l%u_][%w_]*$") and not keyword[n]
    local safe = plain and n or '['..safestr(n)..']'
    return (path or '')..(plain and path and '.' or '')..safe, safe end
  local alphanumsort = type(opts.sortkeys) == 'function' and opts.sortkeys or function(k, o, n) -- k=keys, o=originaltable, n=padding
    local maxn, to = tonumber(n) or 12, {number = 'a', string = 'b'}
    local function padnum(d) return ("%0"..tostring(maxn).."d"):format(tonumber(d)) end
    table.sort(k, function(a,b)
      -- sort numeric keys first: k[key] is not nil for numerical keys
      return (k[a] ~= nil and 0 or to[type(a)] or 'z')..(tostring(a):gsub("%d+",padnum))
           < (k[b] ~= nil and 0 or to[type(b)] or 'z')..(tostring(b):gsub("%d+",padnum)) end) end
  local function val2str(t, name, indent, insref, path, plainindex, level)
    local ttype, level, mt = type(t), (level or 0), getmetatable(t)
    local spath, sname = safename(path, name)
    local tag = plainindex and
      ((type(name) == "number") and '' or name..space..'='..space) or
      (name ~= nil and sname..space..'='..space or '')
    if seen[t] then -- already seen this element
      sref[#sref+1] = spath..space..'='..space..seen[t]
      return tag..'nil'..comment('ref', level)
    end
    -- protect from those cases where __tostring may fail
    if type(mt) == 'table' and metatostring ~= false then
      local to, tr = pcall(function() return mt.__tostring(t) end)
      local so, sr = pcall(function() return mt.__serialize(t) end)
      if (to or so) then -- knows how to serialize itself
        seen[t] = insref or spath
        t = so and sr or tr
        ttype = type(t)
      end -- new value falls through to be serialized
    end
    if ttype == "table" then
      if level >= maxl then return tag..'{}'..comment('maxlvl', level) end
      seen[t] = insref or spath
      if next(t) == nil then return tag..'{}'..comment(t, level) end -- table empty
      if maxlen and maxlen < 0 then return tag..'{}'..comment('maxlen', level) end
      local maxn, o, out = math.min(#t, maxnum or #t), {}, {}
      for key = 1, maxn do o[key] = key end
      if not maxnum or #o < maxnum then
        local n = #o -- n = n + 1; o[n] is much faster than o[#o+1] on large tables
        for key in pairs(t) do
          if o[key] ~= key then n = n + 1; o[n] = key end
        end
      end
      if maxnum and #o > maxnum then o[maxnum+1] = nil end
      if opts.sortkeys and #o > maxn then alphanumsort(o, t, opts.sortkeys) end
      local sparse = sparse and #o > maxn -- disable sparsness if only numeric keys (shorter output)
      for n, key in ipairs(o) do
        local value, ktype, plainindex = t[key], type(key), n <= maxn and not sparse
        if opts.valignore and opts.valignore[value] -- skip ignored values; do nothing
        or opts.keyallow and not opts.keyallow[key]
        or opts.keyignore and opts.keyignore[key]
        or opts.valtypeignore and opts.valtypeignore[type(value)] -- skipping ignored value types
        or sparse and value == nil then -- skipping nils; do nothing
        elseif ktype == 'table' or ktype == 'function' or badtype[ktype] then
          if not seen[key] and not globals[key] then
            sref[#sref+1] = 'placeholder'
            local sname = safename(iname, gensym(key)) -- iname is table for local variables
            sref[#sref] = val2str(key,sname,indent,sname,iname,true)
          end
          sref[#sref+1] = 'placeholder'
          local path = seen[t]..'['..tostring(seen[key] or globals[key] or gensym(key))..']'
          sref[#sref] = path..space..'='..space..tostring(seen[value] or val2str(value,nil,indent,path))
        else
          out[#out+1] = val2str(value,key,indent,nil,seen[t],plainindex,level+1)
          if maxlen then
            maxlen = maxlen - #out[#out]
            if maxlen < 0 then break end
          end
        end
      end
      local prefix = string.rep(indent or '', level)
      local head = indent and '{\n'..prefix..indent or '{'
      local body = table.concat(out, ','..(indent and '\n'..prefix..indent or space))
      local tail = indent and "\n"..prefix..'}' or '}'
      return (custom and custom(tag,head,body,tail,level) or tag..head..body..tail)..comment(t, level)
    elseif badtype[ttype] then
      seen[t] = insref or spath
      return tag..globerr(t, level)
    elseif ttype == 'function' then
      seen[t] = insref or spath
      if opts.nocode then return tag.."function() --[[..skipped..]] end"..comment(t, level) end
      local ok, res = pcall(string.dump, t)
      local func = ok and "((loadstring or load)("..safestr(res)..",'@serialized'))"..comment(t, level)
      return tag..(func or globerr(t, level))
    else return tag..safestr(t) end -- handle all other types
  end
  local sepr = indent and "\n" or ";"..space
  local body = val2str(t, name, indent) -- this call also populates sref
  local tail = #sref>1 and table.concat(sref, sepr)..sepr or ''
  local warn = opts.comment and #sref>1 and space.."--[[incomplete output with shared/self-references skipped]]" or ''
  return not name and body..warn or "do local "..body..sepr..tail.."return "..name..sepr.."end"
end

local function deserialize(data, opts)
  local env = (opts and opts.safe == false) and G
    or setmetatable({}, {
        __index = function(t,k) return t end,
        __call = function(t,...) error("cannot call functions") end
      })
  local f, res = (loadstring or load)('return '..data, nil, nil, env)
  if not f then f, res = (loadstring or load)(data, nil, nil, env) end
  if not f then return f, res end
  if setfenv then setfenv(f, env) end
  return pcall(f)
end

local function merge(a, b) if b then for k,v in pairs(b) do a[k] = v end end; return a; end
return { _NAME = n, _COPYRIGHT = c, _DESCRIPTION = d, _VERSION = v, serialize = s,
  load = deserialize,
  dump = function(a, opts) return s(a, merge({name = '_', compact = true, sparse = true}, opts)) end,
  line = function(a, opts) return s(a, merge({sortkeys = true, comment = true}, opts)) end,
  block = function(a, opts) return s(a, merge({indent = '  ', sortkeys = true, comment = true}, opts)) end }
</file>

<file path="memory-bank/activeContext.md">
### **ACTIVE CONTEXT: "SHATTERED EXPANSE"**

---

### **CURRENT WORK FOCUS**
- Enhancing UI/UX elements
- Finalizing meta-progression implementation
- Rendering improvements

---

### **RECENT CHANGES**
- Implemented contract system with scroll discovery
- Added contract UI display
- Added contract progress tracking
- Implemented contract reward distribution
- Updated world generation to include contract scrolls

---

### **NEXT STEPS**
1. **Enhanced Rendering**:
   - Replace landmark "?" placeholders with proper visuals
   - Implement smooth fog of war transitions
   - Add biome-specific tile textures

2. **Save/Load System**:
   - Integrate serpent.lua for serialization
   - Implement persistent meta-progression
   - Add save/load handlers

3. **UI Improvements**:
   - Polish contract UI layout
   - Add visual indicators for active contracts
   - Implement inventory capacity limits

---

### **ACTIVE DECISIONS AND CONSIDERATIONS**
- Using a global GameState table for simplicity
- Separating run-specific state from persistent meta-state
- Implementing systems as decoupled modules
- Using observer pattern for contract events
- Using placeholder "S" for contract scrolls until art assets are ready

---

### **IMPORTANT PATTERNS AND PREFERENCES**
- Keep Lua modules focused and single-responsibility
- Use descriptive variable and function names
- Add comments for complex algorithms
- Follow Love2D callback structure (load, update, draw)
- Precompute values where possible for performance

---

### **LEARNINGS AND PROJECT INSIGHTS**
- Contract system provides clear player direction
- Scroll discovery mechanic encourages exploration
- UI space is limited - need to design compact information displays
- Reward distribution needs balancing
- Contract progress tracking impacts performance - needs optimization
</file>

<file path="memory-bank/productContext.md">
### **PRODUCT CONTEXT: "SHATTERED EXPANSE"**

---

### **WHY THIS PROJECT EXISTS**
- To create a unique roguelite experience focused on exploration rather than combat
- Address the lack of risk/reward exploration games in the Love2D ecosystem
- Provide a compelling meta-progression system that encourages repeated playthroughs

---

### **PROBLEMS SOLVED**
1. **Exploration Fatigue**: Players often lose interest after initial exploration. Our contract system provides constant objectives.
2. **Permadeath Frustration**: Meta-progression ensures players always make meaningful progress.
3. **Procedural Generation Monotony**: Diverse biomes with unique hazards create varied gameplay experiences.

---

### **HOW IT SHOULD WORK**
1. **Core Loop**:
   - Generate new world with unique biome layout
   - Accept exploration contracts
   - Gather resources while managing stamina
   - Die and bank progress
   - Unlock abilities for next run
2. **User Flow**:
   ```mermaid
   graph TD
     A[New Game] --> B[Generate World]
     B --> C[Explore Biomes]
     C --> D[Complete Contracts]
     D --> E[Gain Abilities/Resources]
     E --> F[Die & Save Progress]
     F --> B
   ```

---

### **USER EXPERIENCE GOALS**
- **Discovery**: Players should feel excitement when uncovering new biomes and landmarks
- **Tension**: Stamina management and hazards should create risk/reward decisions
- **Progression**: Each run should provide tangible improvements for future runs
- **Accessibility**: Simple controls with deep emergent gameplay
</file>

<file path="memory-bank/progress.md">
### **PROGRESS: "SHATTERED EXPANSE"**

---

### **CURRENT STATUS**
- Project documentation complete
- Initial project setup complete
- World generation implemented
- Player movement implemented
- Hazard system implemented
- Basic UI implemented
- Meta-progression foundation implemented
- Contract system implemented

---

### **WHAT WORKS**
- Memory bank documentation system
- Project structure planning
- Biome generation with Perlin noise
- Player movement with arrow keys
- Biome-specific hazard effects
- Player death handling
- Meta-progression saving
- Landmark discovery
- Inventory system
- UI for position, stamina, inventory, and meta resources
- Contract system (generation, tracking, rewards)

---

### **WHAT'S LEFT TO BUILD**
1. **Core Systems**:
   - Enhanced rendering (landmarks, fog of war)
   - Save/load functionality

2. **Supporting Systems**:
   - Audio system
   - Resource management

3. **Content**:
   - Landmark visual assets
   - Ability unlocks

---

### **KNOWN ISSUES**
- Hazard probabilities may need balancing
- Inventory lacks capacity limits
- Landmarks not visually represented
- Contract UI needs polish

---

### **EVOLUTION OF PROJECT DECISIONS**
- **2025-06-13**: Established project documentation standards
- **2025-06-13**: Decided on singleton GameState pattern
- **2025-06-13**: Chose observer pattern for event-driven systems
- **2025-06-13**: Selected Perlin noise for procedural generation
- **2025-06-13**: Implemented simplified inventory system for prototype
- **2025-06-13**: Added meta-progression saving on player death
- **2025-06-14**: Implemented contract system with scroll discovery
</file>

<file path="memory-bank/projectbrief.md">
### **PROJECT BRIEF: "SHATTERED EXPANSE"**  
**For AI Coding Agent Implementation (Love2D Engine)**  

---

### **1. CORE CONCEPT**  
**Genre**: Roguelite Open-World Exploration  
**Objective**: Create a tile-based game where players explore procedurally generated biomes, complete exploration contracts, and unlock meta-progression through permadeath cycles. Combat is minimal; focus is on risk/reward exploration.

---

### **2. TECHNICAL SPECIFICATIONS**  
**Engine**: Love2D (Lua)  
**Dependencies**:  
- `perlin.lua` (procedural generation)  
- `serpent.lua` (save/load serialization)  
**Grid System**: 100x100 world (1 tile = 32px)  

---

### **3. GAME STATE STRUCTURE**  
```lua
GameState = {
  world = {  -- Generated each run
    width = 100,
    height = 100,
    tiles = {}  -- 2D array [x][y]
  },
  
  player = {
    x = 1, y = 1,
    stamina = 100,
    inventory = {torch = 3, rope = 2},
    abilities = {}
  },
  
  contracts = {
    active = {},  -- Current objectives
    completed = 0
  },
  
  meta = {  -- Persists across runs
    unlocked_abilities = {"basic_map"},
    banked_resources = {crystal = 0},
    discovered_landmarks = {}
  }
}
```

---

### **4. WORLD GENERATION REQUIREMENTS**  
**Biome Types**:  
| ID | Name | Risk | Color | Hazard |  
|----|-------|------|----------|---------|  
| 1 | Rusted Oasis | Low | (200,180,100) | None |  
| 2 | Veiled Jungle | Medium | (30,120,40) | 20% stamina drain |  
| 3 | Stormspire Peaks | High | (120,120,140) | 40% stamina drain or reward |  

**Generation Algorithm**:  
```python
1. Initialize 100x100 grid  
2. Generate Perlin noise map (scale=0.1)  
3. Assign biomes:  
   - noise < 0.3 → Biome 1  
   - 0.3 ≤ noise < 0.6 → Biome 2  
   - noise ≥ 0.6 → Biome 3  
4. Place 20 landmarks:  
   - Types: ["Temple", "Caravan", "Cave", "Monolith"]  
   - At random walkable positions  
   - Properties: {type, discovered, reward_type}  
```

---

### **5. CORE MECHANICS**  
**A. Player Movement**  
- Arrow keys move player 1 tile  
- Each move:  
  - Deduct 10 stamina  
  - Reveal tiles in 3-tile radius  
  - Trigger hazard check  

**B. Hazard System**  
```lua
function checkHazard(player_x, player_y)
  tile = world.tiles[player_x][player_y]
  if tile.biome == 2 and math.random() < 0.2 then
    player.stamina -= 10
  elseif tile.biome == 3 and math.random() < 0.4 then
    if math.random() < 0.7 then player.stamina -= 20
    else player:add_resource("relic_fragment")
  end
end
```

**C. Contracts System**  
**Contract Types**:  
1. `discover_landmark`: Find specific landmark type  
2. `explore_biome`: Reveal X% of biome tiles  
3. `collect_resource`: Gather Y units of resource  

**Flow**:  
```mermaid
graph TD
  A[Contract Generated] --> B[Track Progress]
  B --> C{Completed?}
  C -->|Yes| D[Grant Reward]
  D --> E[Generate New Contract]
```

---

### **6. META-PROGRESSION SYSTEM**  
**Persistent Elements**:  
- Unlocked abilities (e.g., "glide", "hazard_resist")  
- Banked resources (max 1 saved per run)  
- Discovered landmark coordinates  

**Death Handling**:  
```lua
function onPlayerDeath()
  saveToMeta({
    resources = player.inventory.most_valuable,
    landmarks = world.newly_discovered_landmarks
  })
  resetWorld()
end
```

---

### **7. RENDERING REQUIREMENTS**  
**Visual Rules**:  
```
if tile.explored:
  draw biome_color + landmark_icon if discovered
else:
  draw BLACK
player: RED circle at (x*32, y*32)
```

**UI Elements**:  
- Top-left: Stamina bar (GREEN/YELLOW/RED gradient)  
- Top-right: Active contract description  
- Bottom-right: Inventory counts  

---

### **8. SAVE/LOAD SYSTEM**  
**Data to Persist**:  
- `meta.unlocked_abilities`  
- `meta.banked_resources`  
- `meta.discovered_landmarks`  

**Operations**:  
```lua
function saveGame()
  serialized = serpent.dump(GameState.meta)
  love.filesystem.write("save.dat", serialized)
end

function loadGame()
  if save_exists then
    GameState.meta = serpent.load(love.filesystem.read("save.dat"))
  end
end
```

---

### **9. DEVELOPMENT PRIORITIES**  
1. World generation + rendering  
2. Player movement + fog of war  
3. Hazard system  
4. Contract tracking  
5. Meta-progression persistence  
6. UI implementation  

---

### **10. TEST CASES**  
```gherkin
Scenario: Biome Hazard Trigger
  Given player is in Veiled Jungle
  When player moves to new tile
  Then 20% chance to lose 10 stamina

Scenario: Contract Completion
  Given "Find Temple" contract
  When player discovers Temple landmark
  Then contract marked complete
  And "glide" ability unlocked

Scenario: Death Sequence
  Given player has 5 crystals
  When stamina reaches 0
  Then crystals saved to meta
  And new world generated
</file>

<file path="memory-bank/systemPatterns.md">
### **SYSTEM PATTERNS: "SHATTERED EXPANSE"**

---

### **ARCHITECTURE OVERVIEW**
```mermaid
graph TD
    A[Love2D Engine] --> B[Game Initialization]
    B --> C[World Generation]
    B --> D[Game State Loading]
    C --> E[Game Loop]
    D --> E
    E --> F[Input Handling]
    F --> G[Player Movement]
    G --> H[Hazard System]
    H --> I[Contract System]
    I --> J[Progression System]
    J --> K[Rendering System]
    K --> E
```

---

### **KEY TECHNICAL DECISIONS**
1. **Procedural Generation**
   - Custom Perlin noise implementation for biome distribution
   - Random landmark placement with walkability checks
   - Tile-based world representation (100x100 grid)
2. **Game State Management**
   - Single global `GameState` table
   - Separation of run-specific state and persistent meta-state
   - Serialization using Serpent library

3. **Systems Design**
   - Decoupled systems: Movement, Hazard, Contract, Progression
   - Event-driven hazard system triggered on movement
   - Observer pattern for contract completion events

4. **Rendering Pipeline**
   - Batch rendering for tile-based world
   - Fog of war implementation using exploration flag
   - Immediate mode UI for HUD elements

---

### **DESIGN PATTERNS**
1. **Singleton Pattern**
   - Global `GameState` acts as central data store
   - Avoids complex state passing between systems

2. **Observer Pattern**
   - Contract system observes player discoveries
   - Hazard system observes player movement

3. **Strategy Pattern**
   - Different hazard implementations per biome
   - Different contract types with unique completion criteria

---

### **CRITICAL IMPLEMENTATION PATHS**
1. **World Generation Sequence**
```mermaid
sequenceDiagram
    Love2D->>WorldGen: love.load()
    WorldGen->>WorldGen: Initialize grid
    WorldGen->>Perlin: Generate noise map
    Perlin-->>WorldGen: Noise values
    WorldGen->>WorldGen: Assign biomes
    WorldGen->>LandmarkPlacer: Place landmarks
    LandmarkPlacer-->>WorldGen: Landmark positions
```

2. **Game Loop Execution**
```mermaid
sequenceDiagram
    loop Every frame
        Love2D->>Input: Process events
        Input->>Player: Handle movement
        Player->>World: Update position
        World->>Hazard: Check tile
        Hazard->>Player: Apply effects
        Player->>Contract: Check discoveries
        Contract->>Progression: Update progress
        Progression->>UI: Update HUD
        UI->>Renderer: Draw frame
    end
```

3. **Death Handling Flow**
```mermaid
flowchart TD
    A[Stamina <= 0] --> B[Save Resources]
    B --> C[Save Discoveries]
    C --> D[Reset World]
    D --> E[Generate New World]
    E --> F[Reset Player State]
    F --> G[Load Persistent Abilities]
    G --> H[Continue Game]
</file>

<file path="memory-bank/techContext.md">
### **TECH CONTEXT: "SHATTERED EXPANSE"**

---

### **TECHNOLOGIES USED**
- **Primary Engine**: Love2D (v11.4)
- **Programming Language**: Lua (5.1)
- **Dependencies**:
  - `serpent.lua`: Serialization for save/load functionality
- **Development Tools**:
  - VS Code with Lua Language Server extension
  - Love2D debugger

---

### **DEVELOPMENT SETUP**
1. **Environment Configuration**:
   - Install Love2D framework
   - Clone project repository
   - Install dependencies via LuaRocks:
     ```
     luarocks install serpent
     ```
2. **Project Structure**:
   ```
   /src
     /world        - World generation and management
     /entities     - Player and game entities
     /systems      - Game systems (movement, hazards, etc.)
     /ui           - User interface components
     /utils        - Utility functions and helpers
   main.lua        - Entry point
   ```

3. **Build & Run**:
   - Execute with: `love .` in project root
   - Debug with VS Code Love2D launch configuration

---

### **TECHNICAL CONSTRAINTS**
1. **Performance Limitations**:
   - Tile-based rendering must be optimized for 100x100 grid
   - Perlin noise generation should be precomputed at world creation
   - Avoid expensive operations in main game loop

2. **Memory Management**:
   - Lua garbage collection can cause hitches
   - Minimize table allocations during gameplay
   - Use object pooling for entities

3. **Platform Support**:
   - Target platforms: Windows, macOS, Linux
   - Screen resolution: Minimum 1024x768

---

### **DEPENDENCIES**
1. **Core Dependencies**:
   - `serpent.lua`: MIT License
2. **Version Constraints**:
   - Love2D: 11.4+
   - Lua: 5.1+

3. **Dependency Management**:
   - Dependencies included in `lib/` directory
   - No external package manager required

---

### **TOOL USAGE PATTERNS**
1. **Development Workflow**:
   - TDD approach with busted unit tests
   - Version control with Git
   - Continuous integration for build verification

2. **Debugging Practices**:
   - Love2D's built-in console output
   - VS Code debugger with breakpoints
   - Runtime performance profiling

3. **Asset Management**:
   - Sprites stored in `assets/sprites/`
   - Fonts stored in `assets/fonts/`
   - Configuration files in `config/`
</file>

<file path="src/world/world_generation.lua">
-- src/world/world_generation.lua
-- Simple Perlin noise implementation

-- Permutation table
local perm = {}
for i = 0, 255 do
    perm[i] = math.random(0, 255)
end

-- Fade function
local function fade(t)
    return t * t * t * (t * (t * 6 - 15) + 10)
end

-- Linear interpolation
local function lerp(t, a, b)
    return a + t * (b - a)
end

-- Gradient function
local function grad(hash, x, y, z)
    local h = hash % 16
    local u = h < 8 and x or y
    local v = h < 4 and y or (h == 12 or h == 14) and x or z
    return ((h % 2) == 0 and u or -u) + ((h % 3) == 0 and v or -v)
end

-- 2D Perlin noise
local function noise(x, y)
    local X = math.floor(x) % 255
    local Y = math.floor(y) % 255
    
    x = x - math.floor(x)
    y = y - math.floor(y)
    
    local u = fade(x)
    local v = fade(y)
    
    local a  = perm[X] + Y
    local aa = perm[a % 255]
    local ab = perm[(a+1) % 255]
    local b  = perm[(X+1) % 255] + Y
    local ba = perm[b % 255]
    local bb = perm[(b+1) % 255]
    
    return lerp(v, lerp(u, grad(perm[aa % 255], x, y, 0),
                        grad(perm[ba % 255], x-1, y, 0)),
                lerp(u, grad(perm[ab % 255], x, y-1, 0),
                        grad(perm[bb % 255], x-1, y-1, 0)))
end

local WorldGeneration = {}

-- Biome definitions
WorldGeneration.BIOMES = {
    {id = 1, name = "Rusted Oasis", color = {200, 180, 100}, risk = "Low", hazard = "None"},
    {id = 2, name = "Veiled Jungle", color = {30, 120, 40}, risk = "Medium", hazard = "20% stamina drain"},
    {id = 3, name = "Stormspire Peaks", color = {120, 120, 140}, risk = "High", hazard = "40% stamina drain or reward"}
}

local LANDMARK_TYPES = {"Temple", "Caravan", "Cave", "Monolith", "Contract_Scroll"}

-- Generate a new world
function WorldGeneration.generateWorld(width, height)
    local world = {
        width = width,
        height = height,
        tiles = {}
    }
    
    -- Initialize empty grid
    for x = 1, width do
        world.tiles[x] = {}
        for y = 1, height do
            world.tiles[x][y] = {
                biome = nil,
                explored = false,
                landmark = nil
            }
        end
    end
    
    -- Assign biomes based on noise
    for x = 1, width do
        for y = 1, height do
            local noiseValue = noise(x * 0.1, y * 0.1)
            local tile = world.tiles[x][y]
            
            if noiseValue < 0.3 then
                tile.biome = WorldGeneration.BIOMES[1]
            elseif noiseValue < 0.6 then
                tile.biome = WorldGeneration.BIOMES[2]
            else
                tile.biome = WorldGeneration.BIOMES[3]
            end
        end
    end
    
    -- Place landmarks
    for i = 1, 20 do
        local placed = false
        while not placed do
            local x = math.random(1, width)
            local y = math.random(1, height)
            local tile = world.tiles[x][y]
            
            -- Only place landmarks on walkable tiles (non-peak biomes)
            if tile.biome.id ~= 3 then
                local landmarkType
                
                -- Randomly decide if this should be a contract scroll (25% chance)
                if math.random() < 0.25 then
                    landmarkType = "Contract_Scroll"
                else
                    landmarkType = LANDMARK_TYPES[math.random(#LANDMARK_TYPES - 1)]  -- Exclude scroll from normal selection
                end
                
                tile.landmark = {
                    type = landmarkType,
                    discovered = false,
                    visited = false,
                    reward_type = landmarkType == "Contract_Scroll" and "contract" or "ability_" .. math.random(1, 5)
                }
                placed = true
            end
        end
    end
    
    return world
end

return WorldGeneration
</file>

<file path="main.lua">
-- main.lua
-- Entry point for Shattered Expanse game

-- Game state
local GameState = {
    world = nil,
    player = {
        x = 1,
        y = 1,
        stamina = 100,
        inventory = {},
        abilities = {}
    },
    meta = {
        banked_resources = {crystal = 0},
        unlocked_abilities = {"basic_map"},
        discovered_landmarks = {}
    },
    viewMode = "zoomed", -- "zoomed" or "minimap"
    camera = {
        x = 1,
        y = 1
    }
}

-- Load dependencies
local WorldGeneration = require("src.world.world_generation")
local ContractSystem = require("src.systems.contract_system")

function love.load()
    -- Initialize game world
    GameState.world = WorldGeneration.generateWorld(100, 100)
    print("World generated with dimensions: " .. GameState.world.width .. "x" .. GameState.world.height)
    
    -- Set default font
    love.graphics.setFont(love.graphics.newFont(14))
    
    -- Initialize contracts
    GameState.contracts = {
        active = {},
        completed = 0
    }
    
    -- Generate initial contract
    local initialContract = ContractSystem.generateContract()
    table.insert(GameState.contracts.active, initialContract)
end

function love.update(dt)
    -- Update contract progress
    for i, contract in ipairs(GameState.contracts.active) do
        if not contract.completed then
            -- Check contract completion
            if ContractSystem.checkCompletion(contract, GameState.player, GameState.world) then
                ContractSystem.grantReward(contract, GameState.player)
                GameState.contracts.completed = GameState.contracts.completed + 1
            end
        end
    end
end

function love.draw()
    local screenWidth, screenHeight = love.graphics.getDimensions()
    local tileSize = GameState.viewMode == "zoomed" and 32 or 6
    local viewSize = 10  -- Tiles visible in each direction in zoomed view
    
    -- Update camera position in zoomed mode with boundary constraints
    if GameState.viewMode == "zoomed" then
        GameState.camera.x = math.max(viewSize + 1, math.min(GameState.player.x, GameState.world.width - viewSize))
        GameState.camera.y = math.max(viewSize + 1, math.min(GameState.player.y, GameState.world.height - viewSize))
    end
    
    -- Calculate visible area based on view mode
    local startX, endX, startY, endY
    
    if GameState.viewMode == "zoomed" then
        -- Show tiles around camera position
        startX = GameState.camera.x - viewSize
        endX = GameState.camera.x + viewSize
        startY = GameState.camera.y - viewSize
        endY = GameState.camera.y + viewSize
    else
        -- Show entire world for minimap
        startX = 1
        endX = GameState.world.width
        startY = 1
        endY = GameState.world.height
    end
    
    -- Render world grid
    for x = startX, endX do
        for y = startY, endY do
            local tile = GameState.world.tiles[x][y]
            local screenX, screenY
            
            if GameState.viewMode == "zoomed" then
                -- Center player on screen
                screenX = (x - startX) * tileSize + (screenWidth - (endX - startX + 1) * tileSize) / 2
                screenY = (y - startY) * tileSize + (screenHeight - (endY - startY + 1) * tileSize) / 2
            else
                screenX = (x-1)*tileSize
                screenY = (y-1)*tileSize
            end
            
            if tile.explored then
                -- Draw biome color
                love.graphics.setColor(tile.biome.color[1]/255, tile.biome.color[2]/255, tile.biome.color[3]/255)
                love.graphics.rectangle("fill", screenX, screenY, tileSize, tileSize)
                
                -- Draw symbol for discovered but unvisited landmarks
                if tile.landmark and tile.landmark.discovered and not tile.landmark.visited then
                    love.graphics.setColor(1, 1, 1)  -- White
                    if tile.landmark.type == "Contract_Scroll" then
                        love.graphics.print("S", screenX + tileSize/2 - 3, screenY + tileSize/2 - 7)
                    else
                        love.graphics.print("?", screenX + tileSize/2 - 3, screenY + tileSize/2 - 7)
                    end
                end
            else
                -- Unexplored tiles are black
                love.graphics.setColor(0, 0, 0)
                love.graphics.rectangle("fill", screenX, screenY, tileSize, tileSize)
            end
        end
    end
    
    -- Render player
    local playerScreenX, playerScreenY
    if GameState.viewMode == "zoomed" then
        -- Calculate player position relative to camera
        local playerOffsetX = (GameState.player.x - GameState.camera.x) * tileSize
        local playerOffsetY = (GameState.player.y - GameState.camera.y) * tileSize
        playerScreenX = screenWidth/2 + playerOffsetX - tileSize/2
        playerScreenY = screenHeight/2 + playerOffsetY - tileSize/2
    else
        -- In minimap view, center player in the tile
        playerScreenX = (GameState.player.x-1)*tileSize
        playerScreenY = (GameState.player.y-1)*tileSize
    end
    
    -- Draw player at center of tile
    love.graphics.setColor(1, 0, 0)  -- Red
    love.graphics.circle("fill", playerScreenX + tileSize/2, playerScreenY + tileSize/2, tileSize/2)
    
    -- Render UI text
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("Shattered Expanse - World View", 10, 10)
    love.graphics.print("Player Position: " .. GameState.player.x .. ", " .. GameState.player.y, 10, 30)
    love.graphics.print("Stamina: " .. GameState.player.stamina, 10, 50)
    
    -- Display current biome info
    local currentTile = GameState.world.tiles[GameState.player.x][GameState.player.y]
    love.graphics.print("Current Biome: " .. currentTile.biome.name, 10, 90)
    love.graphics.print("Hazard: " .. currentTile.biome.hazard, 10, 110)
    love.graphics.print("View Mode: " .. GameState.viewMode .. " (Press 'M' to toggle)", 10, 130)
    
    -- Render inventory
    if GameState.player.inventory then
        local yOffset = 150  -- Adjusted for new view mode info
        for item, count in pairs(GameState.player.inventory) do
            love.graphics.print(item .. ": " .. count, 10, yOffset)
            yOffset = yOffset + 20
        end
    end
    
    -- Render meta resources
    love.graphics.print("Crystals: " .. GameState.meta.banked_resources.crystal, 10, love.graphics.getHeight() - 30)
    
    -- Render active contracts
    if #GameState.contracts.active > 0 then
        love.graphics.setColor(1, 1, 1)
        local yOffset = 30
        for i, contract in ipairs(GameState.contracts.active) do
            local contractType = ContractSystem.CONTRACT_TYPES[contract.type]
            local description = contractType.description
            
            -- Format description with target and required values
            if contract.type == "DISCOVER" then
                description = string.format(description, contract.target)
            elseif contract.type == "EXPLORE" then
                local biomeName = "Unknown"
                if WorldGeneration.BIOMES[contract.target] then
                    biomeName = WorldGeneration.BIOMES[contract.target].name
                end
                description = string.format(description, contract.required, biomeName)
            elseif contract.type == "COLLECT" then
                description = string.format(description, contract.required, contract.target)
            end
            
            love.graphics.print(description, love.graphics.getWidth() - 250, yOffset)
            love.graphics.print("Progress: " .. contract.progress .. "/" .. contract.required, 
                                love.graphics.getWidth() - 250, yOffset + 20)
            yOffset = yOffset + 50
        end
    end
end

function love.keypressed(key)
    -- Handle key presses
    if key == "escape" then
        love.event.quit()
    elseif key == "up" and GameState.player.y > 1 then
        GameState.player.y = GameState.player.y - 1
        exploreAroundPlayer()
        checkHazard(GameState.player.x, GameState.player.y)
    elseif key == "down" and GameState.player.y < GameState.world.height then
        GameState.player.y = GameState.player.y + 1
        exploreAroundPlayer()
        checkHazard(GameState.player.x, GameState.player.y)
    elseif key == "left" and GameState.player.x > 1 then
        GameState.player.x = GameState.player.x - 1
        exploreAroundPlayer()
        checkHazard(GameState.player.x, GameState.player.y)
    elseif key == "right" and GameState.player.x < GameState.world.width then
        GameState.player.x = GameState.player.x + 1
        exploreAroundPlayer()
        checkHazard(GameState.player.x, GameState.player.y)
    elseif key == "m" then
        -- Toggle between zoomed and minimap views
        if GameState.viewMode == "zoomed" then
            GameState.viewMode = "minimap"
        else
            GameState.viewMode = "zoomed"
        end
    end
    
    -- After any movement, check if player is on a landmark tile
    local currentTile = GameState.world.tiles[GameState.player.x][GameState.player.y]
    if currentTile.landmark and currentTile.landmark.discovered and not currentTile.landmark.visited then
        currentTile.landmark.visited = true
        
        -- Handle different landmark types
        if currentTile.landmark.type == "Contract_Scroll" then
            -- Generate new contract from scroll
            local newContract = ContractSystem.generateContract()
            table.insert(GameState.contracts.active, newContract)
        else
            -- Add reward for regular landmark
            GameState.player.inventory = GameState.player.inventory or {}
            GameState.player.inventory.relic_fragment = (GameState.player.inventory.relic_fragment or 0) + 1
        end
    end
end

-- Explore tiles around player
function exploreAroundPlayer()
    local player = GameState.player
    local world = GameState.world
    
    -- Explore in 3-tile radius with boundary checks
    for dx = -3, 3 do
        for dy = -3, 3 do
            local x = player.x + dx
            local y = player.y + dy
            
            -- Check boundaries before accessing tiles
            if x >= 1 and x <= world.width and y >= 1 and y <= world.height then
                world.tiles[x][y].explored = true
                if world.tiles[x][y].landmark then
                    world.tiles[x][y].landmark.discovered = true
                end
            end
        end
    end
end

function checkHazard(x, y)
    local tile = GameState.world.tiles[x][y]
    local biome_id = tile.biome.id
    
    if biome_id == 2 and math.random() < 0.2 then
        GameState.player.stamina = GameState.player.stamina - 10
    elseif biome_id == 3 and math.random() < 0.4 then
        if math.random() < 0.7 then 
            GameState.player.stamina = GameState.player.stamina - 20
        else
            -- Add relic fragment to inventory (placeholder)
            GameState.player.inventory = GameState.player.inventory or {}
            GameState.player.inventory.relic_fragment = (GameState.player.inventory.relic_fragment or 0) + 1
        end
    end
    
    -- Check for player death
    if GameState.player.stamina <= 0 then
        onPlayerDeath()
    end
end

function onPlayerDeath()
    -- Save the most valuable resource (simplified for now)
    if GameState.player.inventory and GameState.player.inventory.relic_fragment then
        GameState.meta.banked_resources.crystal = GameState.meta.banked_resources.crystal +
            math.floor(GameState.player.inventory.relic_fragment / 2)
    end
    
    -- Save discovered landmarks
    for x = 1, GameState.world.width do
        for y = 1, GameState.world.height do
            local tile = GameState.world.tiles[x][y]
            if tile.landmark and tile.landmark.discovered then
                table.insert(GameState.meta.discovered_landmarks, {
                    x = x, 
                    y = y,
                    type = tile.landmark.type
                })
            end
        end
    end
    
    -- Reset world and player
    GameState.world = WorldGeneration.generateWorld(100, 100)
    GameState.player = {
        x = 1,
        y = 1,
        stamina = 100,
        inventory = {}
    }
    
    -- Load persistent abilities
    GameState.player.abilities = {}
    for _, ability in ipairs(GameState.meta.unlocked_abilities) do
        table.insert(GameState.player.abilities, ability)
    end
end
</file>

</files>
